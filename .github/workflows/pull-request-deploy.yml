name: Prepare Pull Request for Release Deployment

on:
  workflow_dispatch:
    inputs:
      branch:
        description: 'Choose a branch:'
        required: true
        default: stage
        type: choice
        options:
          - stage
          - sre-stage

  push:
    branches:
      - stage
      - sre-stage
    
jobs:
  pull-request-deploy:
    runs-on: common-8gb

    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Setup NodeJS
      uses: actions/setup-node@v3
      with:
        registry-url: "https://npm.pkg.github.com"
        always-auth: true
        node-version: 18

    - name: Install packages
      run: npm install @octokit/rest node-fetch@2.6.6

    - name: Set Branch Variable
      id: set_branch_variable
      run: |
        if [ "${{ inputs.branch }}" == "stage" ] || [ "${{ github.event.ref }}" == "refs/heads/stage" ]; then
          echo "BRANCH=stage" >> $GITHUB_OUTPUT
        elif [ "${{ inputs.branch }}" == "sre-stage" ] || [ "${{ github.event.ref }}" == "refs/heads/sre-stage" ]; then
          echo "BRANCH=sre-stage" >> $GITHUB_OUTPUT
        fi

    - name: Set Custom Variables
      id: set_custom_variables
      run: |
        if [ "${{ steps.set_branch_variable.outputs.BRANCH }}" == "stage" ]; then
          echo "DISPLAY_BRANCH=Stage" >> $GITHUB_OUTPUT
          echo "RELEASE_TYPE=RC" >> $GITHUB_OUTPUT
        elif [ "${{ steps.set_branch_variable.outputs.BRANCH }}" == "sre-stage" ]; then
          echo "DISPLAY_BRANCH=SRE-Stage" >> $GITHUB_OUTPUT
          echo "RELEASE_TYPE=CI/CD" >> $GITHUB_OUTPUT
        fi

    - name: Create Pull Request
      uses: actions/github-script@v6
      with:
        script: |
          const { Octokit } = require('@octokit/rest');
          const nodeFetch = require('node-fetch');

          const token = ${{ secrets.ORG_GITHUB_PACKAGES_READER }};

          const octokit = new Octokit({
            auth: token
            request: {
              fetch: nodeFetch
            }
          });
        
          const branch = '${{ steps.set_branch_variable.outputs.BRANCH }}';
          const displayBranch = '${{ steps.set_custom_variables.outputs.DISPLAY_BRANCH }}';
          const releaseType = '${{ steps.set_custom_variables.outputs.RELEASE_TYPE }}';
          
          const { repo, owner } = context.repo;

          const comparison = await github.rest.repos.compareCommits({
            owner: owner,
            repo: repo,
            base: 'main',
            head: branch
          });

          const commitMessages = comparison.data.commits.map(commit => commit.commit.message).join(" ");
          const revertCommits = [...new Set(commitMessages.match(/\bREVERT\b/gi))];
          const extractedTicketCommits = [...new Set(commitMessages.match(/DS-[0-9]+/gi))];
          const ticketSummary  = extractedTicketCommits.length == 0 ? '[No commits with ticket numbers yet]' : extractedTicketCommits.join(" ").toUpperCase();
          const revertCommitsSummary = revertCommits.length != 0 ? 'revert commit detected' : 'no revert commit detected';

          console.log('Commit Messages: ', commitMessages);
          console.log('Reverted Commits Summary: ', revertCommits);
          console.log('Ticket Summary: ', ticketSummary);

          const currentDate = new Date().toISOString().split('T')[0];

          const pullRequestTitle = `${ticketSummary} : ${displayBranch} to Master : [insert RFC ticket] ${releaseType} Release ${currentDate}`;

          const pulls = await github.rest.pulls.list({
              owner: owner,
              repo: repo,
              base: 'main',
              head: branch,
              state: 'open',
          });

          const findPull = pulls.data.find(pr => pr.head.ref === branch);

          if (findPull === null || findPull === undefined) {
            const createPull = await github.rest.pulls.create({
              title: pullRequestTitle,
              owner: owner,
              repo: repo,
              base: 'main',
              head: branch
            });

            await github.rest.issues.addLabels({
              owner: owner,
              repo: repo,
              issue_number: createPull.data.number,
              labels: [revertCommitsSummary]
            });

            await octokit.pulls.requestReviewers({
              owner: owner,
              repo: repo,
              pull_number: createPull.data.number,
              reviewers: ['kevinnicholasalmario']
            });
          } 
          
          else {
            await github.rest.pulls.update({
              title: pullRequestTitle,
              owner: owner,
              repo: repo,
              pull_number: findPull.number,
            });

            await octokit.pulls.requestReviewers({
              owner: owner,
              repo: repo,
              pull_number: findPull.number,
              reviewers: ['kevinnicholasalmario']
            });

            if (revertCommitsSummary === 'revert commit detected') {
              const currentLabels = await github.rest.issues.listLabelsOnIssue({
                owner: owner,
                repo: repo,
                issue_number: findPull.number
              });

              const labelExist = currentLabels.data.some(label => label.name === 'no revert commit detected');

              if (labelExist) {
                await github.rest.issues.removeLabel({
                  owner: owner,
                  repo: repo,
                  issue_number: findPull.number,
                  name: 'no revert commit detected'
                });
              }
            }

            await github.rest.issues.addLabels({
              owner: owner,
              repo: repo,
              issue_number: findPull.number,
              labels: [revertCommitsSummary]
            });
          }